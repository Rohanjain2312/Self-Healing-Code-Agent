"""
Benchmark task definitions — Interview + Real-World Hybrid problems.

Tasks are designed to test:
  - Edge case handling (empty inputs, None, single element)
  - Boundary conditions (off-by-one, integer overflow)
  - Data normalization (messy CSV, unicode, inconsistent types)
  - Algorithm correctness under adversarial inputs
  - Real-world data patterns (logs, intervals, phone numbers)

Each task has a description written for the generator agent and
a reference test suite used to evaluate the final output independently
of the adversarial tests generated by the QA agent.
"""

from dataclasses import dataclass, field
from typing import Any


@dataclass
class BenchmarkTask:
    task_id: str
    category: str
    description: str
    # Reference tests: list of (input_args, expected_output) tuples
    # Used for final evaluation only — not given to the agent
    reference_tests: list[dict[str, Any]] = field(default_factory=list)
    # Optional: known tricky aspects for result analysis
    known_difficulty: str = ""


BENCHMARK_TASKS: list[BenchmarkTask] = [
    BenchmarkTask(
        task_id="interval_merge_001",
        category="interval_merging",
        description="""
Write a Python function `merge_intervals(intervals: list[list[int]]) -> list[list[int]]`
that merges all overlapping intervals and returns a sorted list of non-overlapping intervals.

Requirements:
- Input: list of [start, end] pairs (integers). May be unsorted.
- Output: merged, sorted list of [start, end] pairs.
- Handle empty list: return [].
- Handle single interval: return it unchanged.
- Intervals are inclusive on both ends: [1,3] and [3,5] overlap.
- Do not modify the input list.
""".strip(),
        known_difficulty="Off-by-one on touching intervals [1,3],[3,5] → must merge to [1,5]",
    ),

    BenchmarkTask(
        task_id="csv_normalize_001",
        category="data_normalization",
        description="""
Write a Python function `normalize_csv_row(row: dict) -> dict` that normalizes a
single CSV row with messy data.

Normalization rules:
- Strip leading/trailing whitespace from all string values.
- Convert 'phone' field to digits only (remove spaces, dashes, parentheses, dots).
  If phone is empty or None after stripping, set to empty string.
- Convert 'age' field to int. If invalid or missing, set to -1.
- Convert 'email' to lowercase.
- Convert 'name' to title case.
- All other string fields: strip only.

Input dict may have missing keys — handle gracefully with defaults.
Return a new dict (do not modify the input).
""".strip(),
        known_difficulty="Missing keys, None values, partial phone strings",
    ),

    BenchmarkTask(
        task_id="log_dedup_001",
        category="log_processing",
        description="""
Write a Python function `deduplicate_logs(logs: list[str]) -> list[str]` that:
- Removes exact duplicate log lines.
- Preserves the original order of FIRST occurrence.
- Strips trailing whitespace from each line before comparing.
- Returns an empty list for empty input.
- Does not modify the input list.
""".strip(),
        known_difficulty="Order preservation, whitespace stripping before dedup",
    ),

    BenchmarkTask(
        task_id="flatten_nested_001",
        category="data_transformation",
        description="""
Write a Python function `flatten(nested: Any) -> list` that recursively flattens
a nested structure of lists and tuples into a flat list of non-container values.

Requirements:
- Flattens arbitrarily deep nesting.
- Treats strings as scalar values (do NOT flatten characters from strings).
- Handles None as a scalar value (include it in output).
- Handles empty lists and tuples (contribute nothing to output).
- Works with mixed nesting of lists and tuples.
- Input type hint: Any (can be a scalar, list, or tuple at any level).
""".strip(),
        known_difficulty="Strings must not be iterated, None must be preserved",
    ),

    BenchmarkTask(
        task_id="word_frequency_001",
        category="text_processing",
        description="""
Write a Python function `top_k_words(text: str, k: int) -> list[tuple[str, int]]`
that returns the k most frequent words in text, sorted by frequency descending.
Ties are broken alphabetically (ascending).

Requirements:
- Case-insensitive: 'The' and 'the' count as the same word.
- Strip punctuation from word boundaries (., ! ? ; : , etc.) but preserve apostrophes within words.
- Ignore empty strings after stripping.
- Return list of (word, count) tuples.
- If k > unique words, return all unique words.
- Empty text returns [].
""".strip(),
        known_difficulty="Punctuation stripping, tie-breaking by alphabetical order",
    ),

    BenchmarkTask(
        task_id="range_compression_001",
        category="interval_merging",
        description="""
Write a Python function `compress_ranges(numbers: list[int]) -> list[str]`
that compresses a list of integers into range strings.

Examples:
  [1,2,3,5,7,8,9] → ["1-3", "5", "7-9"]
  [1] → ["1"]
  [] → []
  [1,1,2] → ["1-2"]  (duplicates treated as single occurrences)

Requirements:
- Sort input before processing.
- Deduplicate before processing.
- Consecutive integers form a range ("start-end").
- Single integers are represented as their string value.
- Return list of strings in ascending order.
""".strip(),
        known_difficulty="Deduplication before ranging, single-element ranges",
    ),

    BenchmarkTask(
        task_id="safe_divide_001",
        category="boundary_conditions",
        description="""
Write a Python function `safe_divide(numerator: float, denominator: float) -> float | None`
that performs division with full edge case handling.

Rules:
- Return None if denominator is 0 or -0.0.
- Return None if either argument is float('inf') or float('-inf').
- Return None if either argument is float('nan').
- Otherwise return numerator / denominator as float.
- Do not raise any exceptions.
""".strip(),
        known_difficulty="IEEE 754 edge cases: -0.0, inf, nan",
    ),

    BenchmarkTask(
        task_id="anagram_groups_001",
        category="text_processing",
        description="""
Write a Python function `group_anagrams(words: list[str]) -> list[list[str]]`
that groups words that are anagrams of each other.

Requirements:
- Case-insensitive comparison: 'Listen' and 'silent' are anagrams.
- Each group sorted alphabetically internally.
- Output list sorted by first element of each group alphabetically.
- Empty input returns [].
- Single-word input returns [[word]].
- Non-alpha characters count in anagram comparison ('eat!' ≠ 'eat').
""".strip(),
        known_difficulty="Case normalization, deterministic output ordering",
    ),
]


def get_task_by_id(task_id: str) -> BenchmarkTask | None:
    for task in BENCHMARK_TASKS:
        if task.task_id == task_id:
            return task
    return None


def get_tasks_by_category(category: str) -> list[BenchmarkTask]:
    return [t for t in BENCHMARK_TASKS if t.category == category]
